# Анализ текущих зависимостей

## Внешние зависимости

### Основные зависимости
- `github.com/go-telegram/bot` - Telegram Bot API клиент
- `modernc.org/sqlite` - SQLite драйвер без CGO
- `github.com/joho/godotenv` - Загрузка переменных окружения из .env файлов

### Косвенные зависимости
- `github.com/dustin/go-humanize` - Утилиты для форматирования
- `github.com/google/uuid` - UUID генерация
- `github.com/mattn/go-isatty` - Проверка TTY
- `github.com/ncruces/go-strftime` - Форматирование времени
- `github.com/remyoudompheng/bigfft` - Математические операции
- `golang.org/x/exp` - Экспериментальные пакеты Go
- `golang.org/x/sys` - Системные вызовы
- `modernc.org/libc` - C библиотека для SQLite

## Внутренние компоненты (текущее состояние)

### Основные компоненты в main.go:
1. **HTTP Server** - обработка webhook запросов от Telegram
2. **Bot Client** - взаимодействие с Telegram Bot API
3. **Database Layer** - работа с SQLite базой данных
4. **Notification Scheduler** - планирование и отправка уведомлений
5. **Business Logic** - обработка команд пользователей

### Глобальные переменные:
- `b *bot.Bot` - экземпляр Telegram бота
- `db *sql.DB` - соединение с базой данных
- `timers map[int]*time.Timer` - карта активных таймеров уведомлений
- `timersMtx sync.Mutex` - мьютекс для защиты карты таймеров

### Конфигурационные переменные:
- `workStart, workEnd string` - рабочие часы
- `slotDurationMins int` - длительность слота в минутах
- `scheduleDays int` - количество дней для планирования

## Выявленные проблемы зависимостей

### Тесная связанность:
- Все компоненты находятся в одном файле
- Глобальные переменные создают скрытые зависимости
- Бизнес-логика смешана с инфраструктурным кодом

### Отсутствие абстракций:
- Прямое использование *sql.DB во всех функциях
- Нет интерфейсов для подмены компонентов в тестах
- Конфигурация разбросана по глобальным переменным

### Потенциальные race conditions:
- Доступ к глобальным переменным из разных goroutines
- Карта таймеров защищена мьютексом, но логика сложная

## Рекомендации для рефакторинга

1. **Выделить интерфейсы** для всех основных компонентов
2. **Создать конфигурационную структуру** для централизованного управления настройками
3. **Реализовать dependency injection** для уменьшения связанности
4. **Разделить слои** (презентационный, бизнес-логика, доступ к данным)
5. **Добавить контекст** для управления жизненным циклом компонентов
